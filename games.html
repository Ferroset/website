<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ferroserver Games</title>
    <style>
        :root {
            --dark-red: #5A0000;
            --medium-red: #7A0000;
            --light-red: #9A0000;
            --accent-red: #FF6B6B;
            --white: #FFFFFF;
            --light-gray: #F5F5F5;
            --dark-gray: rgba(40, 40, 40, 0.95);
            --darker-gray: #1a1a1a;
            --card-glass: rgba(40, 40, 40, 0.7);
            --success-color: #4CAF50;
            --warning-color: #FF9800;
            --error-color: #F44336;
            --wii-glow: rgba(255, 255, 255, 0.6);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: 
                radial-gradient(ellipse at top, rgba(122, 0, 0, 0.3), transparent 50%),
                radial-gradient(ellipse at bottom, rgba(90, 0, 0, 0.2), transparent 50%),
                linear-gradient(135deg, var(--dark-red), var(--darker-gray));
            color: var(--white);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg"><defs><pattern id="grid" width="100" height="100" patternUnits="userSpaceOnUse"><path d="M 100 0 L 0 0 0 100" fill="none" stroke="rgba(255,255,255,0.03)" stroke-width="1"/></pattern></defs><rect width="100%" height="100%" fill="url(%23grid)"/></svg>');
            pointer-events: none;
            z-index: 0;
        }

        /* Bubbly soda effect container */
        .bubbles-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
            z-index: 0;
        }

        /* Individual bubble */
        .bubble {
            position: absolute;
            bottom: -50px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, 
                rgba(255, 255, 255, 0.25), 
                rgba(255, 255, 255, 0.08));
            opacity: 0.6;
            animation: rise linear infinite;
        }

        @keyframes rise {
            0% {
                bottom: -50px;
                opacity: 0;
            }
            10% {
                opacity: 0.6;
            }
            90% {
                opacity: 0.6;
            }
            100% {
                bottom: 110vh;
                opacity: 0;
            }
        }

        /* Return Button */
        .return-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(90, 0, 0, 0.6);
            color: var(--white);
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 10px 18px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 0.9rem;
            text-decoration: none;
            z-index: 1000;
            backdrop-filter: blur(10px);
            box-shadow: 
                0 4px 0 rgba(0, 0, 0, 0.4),
                2px 2px 0 rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .return-button::before {
            content: '←';
            font-size: 1.2em;
        }

        .return-button:hover {
            background: rgba(122, 0, 0, 0.7);
            transform: translateX(-4px);
            box-shadow: 
                0 6px 0 rgba(0, 0, 0, 0.5),
                3px 3px 0 rgba(0, 0, 0, 0.7);
            border-color: rgba(255, 255, 255, 0.25);
        }

        .return-button:active {
            transform: translateX(-2px);
        }

        /* Splash Screen */
        #splashScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(ellipse at center, rgba(122, 0, 0, 0.4), transparent 70%),
                linear-gradient(135deg, var(--dark-red), var(--darker-gray));
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.6s ease, transform 0.6s ease;
        }

        #splashScreen.fade-out {
            opacity: 0;
            transform: scale(0.98);
        }

        .splash-content {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            animation: fadeInUp 0.8s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .splash-logo {
            max-width: 500px;
            width: 80vw;
            height: auto;
            margin-bottom: 40px;
            filter: drop-shadow(4px 4px 0 rgba(0, 0, 0, 0.9));
            animation: logoFloat 3s ease-in-out infinite;
        }

        @keyframes logoFloat {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-10px);
            }
        }

        .loading-container {
            width: 450px;
            max-width: 80vw;
            margin: 0 auto;
        }

        .loading-bar {
            width: 100%;
            height: 28px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 20px;
            box-shadow: 
                inset 0 2px 0 rgba(0, 0, 0, 0.4),
                0 4px 0 rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
        }

        .loading-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.1), 
                transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% {
                transform: translateX(-100%);
            }
            100% {
                transform: translateX(100%);
            }
        }

        .loading-progress {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, 
                var(--medium-red), 
                var(--accent-red), 
                var(--medium-red));
            background-size: 200% 100%;
            border-radius: 2px;
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 0 2px rgba(255, 107, 107, 0.3);
            animation: progressGlow 2s ease-in-out infinite;
            position: relative;
            overflow: hidden;
        }

        @keyframes progressGlow {
            0%, 100% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
        }

        .loading-text {
            font-size: 1.3rem;
            font-weight: 700;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.9);
            height: 28px;
            letter-spacing: 0.5px;
            color: var(--white);
        }

        /* Main Content */
        #mainContent {
            opacity: 0;
            transition: opacity 0.6s ease;
            z-index: 1;
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
        }

        #mainContent.visible {
            opacity: 1;
        }

        .header {
            text-align: center;
            margin: 40px 0 60px 0;
            z-index: 1;
        }

        .header h1 {
            font-size: 3rem;
            font-weight: 700;
            text-shadow: 3px 3px 0 rgba(0, 0, 0, 0.9);
            margin-bottom: 15px;
            letter-spacing: 1px;
            opacity: 0;
            transform: translateY(-30px);
            animation: none;
        }

        #mainContent.visible .header h1 {
            animation: bounceInDown 0.7s ease-out forwards;
        }

        @keyframes bounceInDown {
            0% {
                opacity: 0;
                transform: translateY(-30px) scale(0.95);
            }
            60% {
                opacity: 1;
                transform: translateY(5px) scale(1.02);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.7);
            transform: translateY(-10px);
            animation: none;
        }

        #mainContent.visible .header p {
            animation: fadeInUp 0.5s ease-out 0.25s forwards;
        }

        @keyframes fadeInUp {
            0% {
                opacity: 0;
                transform: translateY(-10px);
            }
            100% {
                opacity: 0.9;
                transform: translateY(0);
            }
        }

        /* Wii-Style Grid Layout */
        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 40px;
            padding: 20px;
            max-width: 1000px;
            margin: 0 auto;
            z-index: 1;
        }

        /* Wii Channel Tile */
        .channel-tile {
            aspect-ratio: 1;
            background: linear-gradient(145deg, 
                rgba(122, 0, 0, 0.4),
                rgba(90, 0, 0, 0.6));
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 
                0 8px 16px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            opacity: 0;
            transform: scale(0.85) translateY(20px);
            animation: none;
        }

        #mainContent.visible .channel-tile {
            animation: popIn 0.5s ease-out forwards;
        }

        @keyframes popIn {
            0% {
                opacity: 0;
                transform: scale(0.85) translateY(20px);
            }
            60% {
                transform: scale(1.02) translateY(-3px);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        /* Staggered animation delays for each tile */
        #mainContent.visible .games-grid .channel-tile:nth-child(1) {
            animation-delay: 0.4s;
        }
        #mainContent.visible .games-grid .channel-tile:nth-child(2) {
            animation-delay: 0.48s;
        }
        #mainContent.visible .games-grid .channel-tile:nth-child(3) {
            animation-delay: 0.56s;
        }
        #mainContent.visible .games-grid .channel-tile:nth-child(4) {
            animation-delay: 0.64s;
        }
        #mainContent.visible .games-grid .channel-tile:nth-child(5) {
            animation-delay: 0.72s;
        }
        #mainContent.visible .games-grid .channel-tile:nth-child(6) {
            animation-delay: 0.80s;
        }
        #mainContent.visible .games-grid .channel-tile:nth-child(7) {
            animation-delay: 0.88s;
        }
        #mainContent.visible .games-grid .channel-tile:nth-child(8) {
            animation-delay: 0.96s;
        }

        .channel-tile::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at center, 
                transparent 0%, 
                rgba(0, 0, 0, 0.2) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        /* Wii-style hover effect */
        .channel-tile:hover {
            transform: scale(1.08) translateY(-5px);
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 
                0 0 30px rgba(255, 255, 255, 0.3),
                0 0 50px rgba(255, 107, 107, 0.4),
                0 12px 24px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .channel-tile:hover::before {
            opacity: 1;
        }

        .channel-tile:hover::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, 
                rgba(255, 255, 255, 0.3) 0%, 
                transparent 70%);
            animation: wiiGlow 2s ease-in-out infinite;
        }

        @keyframes wiiGlow {
            0%, 100% {
                transform: translate(0, 0);
            }
            50% {
                transform: translate(10px, 10px);
            }
        }

        .channel-tile:active {
            transform: scale(1.02) translateY(-2px);
        }

        /* Placeholder tiles styling */
        .channel-tile.placeholder {
            opacity: 0.6;
            cursor: default;
        }

        .channel-tile.placeholder:hover {
            transform: scale(1.03) translateY(-2px);
            box-shadow: 
                0 0 20px rgba(255, 255, 255, 0.2),
                0 0 30px rgba(255, 107, 107, 0.2),
                0 10px 20px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        .channel-icon {
            font-size: 4rem;
            margin-bottom: 15px;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.5));
            position: relative;
            z-index: 1;
        }

        /* Channel Preview Container */
        .channel-preview {
            width: 100%;
            height: 60%;
            position: relative;
            margin-bottom: 15px;
            z-index: 1;
            opacity: 0;
            animation: none;
        }

        #mainContent.visible .channel-tile .channel-preview {
            animation: fadeIn 0.5s ease-out forwards;
        }

        @keyframes fadeIn {
            0% {
                opacity: 0;
            }
            100% {
                opacity: 1;
            }
        }

        /* Stagger preview animations */
        #mainContent.visible .games-grid .channel-tile:nth-child(1) .channel-preview {
            animation-delay: 0.6s;
        }
        #mainContent.visible .games-grid .channel-tile:nth-child(2) .channel-preview {
            animation-delay: 0.68s;
        }
        #mainContent.visible .games-grid .channel-tile:nth-child(3) .channel-preview {
            animation-delay: 0.76s;
        }
        #mainContent.visible .games-grid .channel-tile:nth-child(4) .channel-preview {
            animation-delay: 0.84s;
        }
        #mainContent.visible .games-grid .channel-tile:nth-child(5) .channel-preview {
            animation-delay: 0.92s;
        }
        #mainContent.visible .games-grid .channel-tile:nth-child(6) .channel-preview {
            animation-delay: 1.0s;
        }
        #mainContent.visible .games-grid .channel-tile:nth-child(7) .channel-preview {
            animation-delay: 1.08s;
        }
        #mainContent.visible .games-grid .channel-tile:nth-child(8) .channel-preview {
            animation-delay: 1.16s;
        }

        /* Dodge-Grays Preview Particles */
        .preview-particle {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(180, 180, 180, 1), rgba(140, 140, 140, 0));
            animation: floatParticle 3s infinite ease-in-out;
        }

        .preview-particle.p1 {
            width: 20px;
            height: 20px;
            top: 20%;
            left: 20%;
            animation-delay: 0s;
        }

        .preview-particle.p2 {
            width: 16px;
            height: 16px;
            top: 60%;
            right: 25%;
            animation-delay: 1s;
        }

        .preview-particle.p3 {
            width: 18px;
            height: 18px;
            bottom: 25%;
            left: 50%;
            animation-delay: 2s;
        }

        @keyframes floatParticle {
            0%, 100% {
                transform: translate(0, 0);
                opacity: 0.8;
            }
            50% {
                transform: translate(10px, -10px);
                opacity: 1;
            }
        }

        /* Dodge-Grays Preview Player */
        .preview-player {
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 107, 107, 1), rgba(220, 70, 70, 0.3));
            border: 2px solid rgba(255, 107, 107, 0.8);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
            animation: playerPulse 2s infinite ease-in-out;
        }

        @keyframes playerPulse {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
            }
            50% {
                transform: translate(-50%, -50%) scale(1.1);
            }
        }

        /* Ferroxel Preview (updated from VoxelCraft) */
        .ferroxel-preview {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        .ferroxel-cube {
            width: 18px;
            height: 18px;
            border: 1px solid rgba(255, 255, 255, 0.4);
            animation: ferroxelFloat 3s infinite ease-in-out;
        }

        .ferroxel-cube.grass { background-color: #3A7D00; animation-delay: 0s; }
        .ferroxel-cube.dirt { background-color: #8B4513; animation-delay: 0.5s; }
        .ferroxel-cube.stone { background-color: #808080; animation-delay: 1s; }
        .ferroxel-cube.wood { background-color: #654321; animation-delay: 1.5s; }

        @keyframes ferroxelFloat {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-8px);
            }
        }

        /* Placeholder Preview */
        .placeholder-preview {
            background: radial-gradient(circle at center, 
                rgba(255, 255, 255, 0.05),
                transparent);
            border: 2px dashed rgba(255, 255, 255, 0.2);
            border-radius: 8px;
        }

        .channel-title {
            font-size: 1.1rem;
            font-weight: 600;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            position: relative;
            z-index: 1;
            line-height: 1.3;
            opacity: 0;
            transform: translateY(5px);
            animation: none;
        }

        #mainContent.visible .channel-tile .channel-title {
            animation: slideUpFade 0.4s ease-out forwards;
        }

        @keyframes slideUpFade {
            0% {
                opacity: 0;
                transform: translateY(5px);
            }
            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Stagger title animations */
        #mainContent.visible .games-grid .channel-tile:nth-child(1) .channel-title {
            animation-delay: 0.7s;
        }
        #mainContent.visible .games-grid .channel-tile:nth-child(2) .channel-title {
            animation-delay: 0.78s;
        }
        #mainContent.visible .games-grid .channel-tile:nth-child(3) .channel-title {
            animation-delay: 0.86s;
        }
        #mainContent.visible .games-grid .channel-tile:nth-child(4) .channel-title {
            animation-delay: 0.94s;
        }
        #mainContent.visible .games-grid .channel-tile:nth-child(5) .channel-title {
            animation-delay: 1.02s;
        }
        #mainContent.visible .games-grid .channel-tile:nth-child(6) .channel-title {
            animation-delay: 1.1s;
        }
        #mainContent.visible .games-grid .channel-tile:nth-child(7) .channel-title {
            animation-delay: 1.18s;
        }
        #mainContent.visible .games-grid .channel-tile:nth-child(8) .channel-title {
            animation-delay: 1.26s;
        }

        /* Game Modal Overlay */
        .game-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            display: none;
            justify-content: center;
            align-items: flex-start; /* Changed from center to flex-start for scrollability */
            z-index: 2000;
            padding: 20px;
            overflow-y: auto; /* Added for scrollability */
            animation: fadeIn 0.3s ease;
        }

        .game-modal.active {
            display: flex;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .modal-content {
            background: linear-gradient(145deg, 
                var(--dark-gray),
                rgba(40, 40, 40, 0.98));
            border-radius: 12px;
            width: 95%;
            max-width: none;
            max-height: none;
            position: relative;
            box-shadow: 
                0 0 40px rgba(255, 107, 107, 0.3),
                0 20px 60px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 2px solid rgba(255, 255, 255, 0.1);
            margin: auto 0; /* Added to center vertically when content is small */
        }

        @keyframes slideIn {
            from {
                transform: scale(0.9) translateY(20px);
                opacity: 0;
            }
            to {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-size: 1.5rem;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            z-index: 10;
            font-weight: bold;
        }

        .modal-close:hover {
            background: rgba(255, 0, 0, 0.9);
            transform: rotate(90deg) scale(1.1);
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
        }

        /* Game Card Styles (inside modal) */
        .game-card {
            background: linear-gradient(145deg, 
                var(--card-glass),
                rgba(40, 40, 40, 0.85));
            border-radius: 8px;
            padding: 30px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            width: 100%;
            height: 100%;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .game-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            flex-wrap: wrap;
            gap: 15px;
        }

        .game-title {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .game-title h2 {
            font-size: 2rem;
            font-weight: 700;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.9);
            margin: 0;
        }

        .game-icon {
            font-size: 2.5rem;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.5));
        }

        .game-description {
            color: rgba(255, 255, 255, 0.9);
            line-height: 1.6;
            margin-bottom: 25px;
            font-size: 1rem;
        }

        /* Game Controls Container */
        .game-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .game-button {
            background: linear-gradient(145deg, var(--medium-red), var(--light-red));
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.3);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .game-button:hover {
            background: linear-gradient(145deg, var(--light-red), var(--accent-red));
            transform: translateY(-2px);
            box-shadow: 0 6px 0 rgba(0, 0, 0, 0.3);
        }

        .game-button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 0 rgba(0, 0, 0, 0.3);
        }

        .game-button.start {
            background: linear-gradient(145deg, #3A7D00, #4CAF50);
        }

        .game-button.start:hover {
            background: linear-gradient(145deg, #4CAF50, #66BB6A);
        }

        .game-button.reset {
            background: linear-gradient(145deg, #7A0000, var(--error-color));
        }

        .game-button.reset:hover {
            background: linear-gradient(145deg, var(--error-color), #FF5252);
        }

        /* Canvas Container */
        .canvas-container {
            position: relative;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 20px;
            box-shadow: 
                inset 0 2px 8px rgba(0, 0, 0, 0.4),
                0 4px 12px rgba(0, 0, 0, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.05);
            flex: 1;
            min-height: 500px;
        }

        #particleGame, #ferroxelCanvas {
            display: block;
            width: 100%;
            height: 100%;
            max-width: none;
        }

        /* Ferroxel UI Styles */
        #ferroxelUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        #ferroxelCrosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            opacity: 0.8;
            display: none;
        }

        #ferroxelCrosshair.active {
            display: block;
        }

        #ferroxelCrosshair::before,
        #ferroxelCrosshair::after {
            content: '';
            position: absolute;
            background: white;
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
        }

        #ferroxelCrosshair::before {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        #ferroxelCrosshair::after {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        #ferroxelInventory {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 5px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            pointer-events: auto;
        }

        #ferroxelInventory.active {
            display: flex;
        }

        .ferroxel-inventory-slot {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .ferroxel-inventory-slot::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, transparent 30%, rgba(255,255,255,0.1) 50%, transparent 70%);
            transform: translateX(-100%);
            transition: transform 0.6s;
        }

        .ferroxel-inventory-slot:hover::before {
            transform: translateX(100%);
        }

        .ferroxel-inventory-slot.active {
            border-color: #FFD700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.6), inset 0 0 10px rgba(255, 215, 0, 0.3);
            transform: scale(1.1);
        }

        .ferroxel-inventory-slot:hover {
            transform: scale(1.05);
            border-color: rgba(255, 255, 255, 0.6);
        }

        .ferroxel-inventory-slot.active:hover {
            transform: scale(1.1);
        }

        .ferroxel-block-preview {
            width: 40px;
            height: 40px;
            background-size: cover;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        #ferroxelControls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            background: rgba(0, 0, 0, 0.6);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 12px;
            line-height: 1.8;
            letter-spacing: 1px;
            animation: fadeIn 1s ease-out;
            display: none;
        }

        #ferroxelControls.active {
            display: block;
        }

        #ferroxelFPS {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 14px;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 10px;
            letter-spacing: 1px;
            display: none;
        }

        #ferroxelFPS.active {
            display: block;
        }

        #ferroxelErrorMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 2000;
            display: none;
        }

        /* Game Stats */
        .game-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-label {
            font-size: 0.85rem;
            opacity: 0.8;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--accent-red);
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.9);
        }

        /* Lives Display */
        .lives-display {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .life-icon {
            width: 30px;
            height: 30px;
            background: var(--accent-red);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        .life-icon.lost {
            background: rgba(244, 67, 54, 0.3);
            opacity: 0.3;
        }

        /* Mobile Controls */
        .mobile-controls {
            display: none;
            grid-template-areas:
                ". up ."
                "left . right"
                ". down .";
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(3, 60px);
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        @media (max-width: 768px) {
            .mobile-controls {
                display: grid;
            }
        }

        .mobile-controls button {
            background: rgba(90, 0, 0, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
            transition: all 0.2s ease;
        }

        .mobile-controls button:active {
            background: rgba(122, 0, 0, 0.8);
            transform: scale(0.95);
        }

        .mobile-controls .up { grid-area: up; }
        .mobile-controls .down { grid-area: down; }
        .mobile-controls .left { grid-area: left; }
        .mobile-controls .right { grid-area: right; }

        /* Game Messages */
        .game-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 8px;
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.2);
            z-index: 100;
        }

        .game-message.visible {
            opacity: 1;
        }

        .game-message.success {
            border-color: var(--success-color);
            color: var(--success-color);
        }

        .game-message.warning {
            border-color: var(--warning-color);
            color: var(--warning-color);
        }

        .game-message.error {
            border-color: var(--error-color);
            color: var(--error-color);
        }

        /* Ferroxel Start Screen */
        #ferroxelStartScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s, transform 0.5s;
            overflow: auto;
            padding: 20px;
            box-sizing: border-box;
        }

        #ferroxelStartScreen::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grid" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M 10 0 L 0 0 0 10" fill="none" stroke="rgba(255,255,255,0.05)" stroke-width="0.5"/></pattern></defs><rect width="100" height="100" fill="url(%23grid)"/></svg>');
            opacity: 0.3;
            pointer-events: none;
        }

        #ferroxelStartScreen.hidden {
            opacity: 0;
            transform: scale(1.1);
            pointer-events: none;
        }

        .ferroxel-title-container {
            text-align: center;
            margin-bottom: 40px;
            position: relative;
            z-index: 2;
            max-width: 100%;
        }

        #ferroxelStartScreen h1 {
            font-size: clamp(40px, 10vw, 80px);
            font-weight: 900;
            color: white;
            text-shadow: 5px 5px 20px rgba(0,0,0,0.5);
            margin-bottom: 10px;
            animation: float 3s ease-in-out infinite;
            letter-spacing: 5px;
            line-height: 1.2;
            word-wrap: break-word;
        }

        #ferroxelStartScreen .subtitle {
            font-size: clamp(16px, 3vw, 20px);
            color: rgba(255, 255, 255, 0.8);
            text-shadow: 2px 2px 10px rgba(0,0,0,0.5);
            letter-spacing: 3px;
            line-height: 1.4;
            max-width: 100%;
            padding: 0 10px;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        #ferroxelStartButton {
            padding: 20px 60px;
            font-size: clamp(18px, 4vw, 24px);
            font-weight: 700;
            background: linear-gradient(135deg, #3A7D00, #8B4513);
            border: none;
            border-radius: 50px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            font-family: 'Orbitron', monospace;
            letter-spacing: 2px;
            position: relative;
            z-index: 2;
            overflow: hidden;
            margin-top: 20px;
        }

        #ferroxelStartButton::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: 0.5s;
        }

        #ferroxelStartButton:hover::before {
            left: 100%;
        }

        #ferroxelStartButton:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.4);
        }

        #ferroxelStartButton:active {
            transform: translateY(0);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }

            .header p {
                font-size: 1rem;
            }

            .games-grid {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 25px;
                padding: 10px;
            }

            .channel-tile {
                border-radius: 12px;
            }

            .channel-icon {
                font-size: 3rem;
            }

            .channel-title {
                font-size: 0.95rem;
            }

            .game-card {
                padding: 20px;
            }

            .game-title h2 {
                font-size: 1.5rem;
            }

            .game-stats {
                grid-template-columns: 1fr 1fr;
            }
            
            .modal-content {
                width: 98%;
                height: 98%;
            }
            
            .game-controls {
                flex-direction: column;
                align-items: center;
            }
            
            .game-button {
                width: 100%;
                max-width: 200px;
            }
        }

        @media (max-width: 480px) {
            .games-grid {
                grid-template-columns: 1fr;
                max-width: 250px;
            }

            .return-button {
                padding: 8px 12px;
                font-size: 0.8rem;
            }
            
            .canvas-container {
                min-height: 300px;
            }
        }
    </style>
</head>
<body>
    <!-- Bubbly Background Effect -->
    <div class="bubbles-container" id="bubblesContainer"></div>

    <!-- Return Button -->
    <a href="index.html" class="return-button">Return to Menu</a>

    <!-- Splash Screen -->
    <div id="splashScreen">
        <div class="splash-content">
            <img src="/images/ferros.png" alt="FerrOS" class="splash-logo">
            
            <div class="loading-container">
                <div class="loading-bar">
                    <div class="loading-progress" id="loadingProgress"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div id="mainContent">
        <div class="header">
            <h1>Ferroserver Game Hub</h1>
            <p>Select a game to play</p>
        </div>

        <!-- Wii-Style Games Grid -->
        <div class="games-grid">
            <!-- Dodge-Grays Channel Tile -->
            <div class="channel-tile active-game" data-game="dodge-grays">
                <div class="channel-preview">
                    <div class="preview-particle p1"></div>
                    <div class="preview-particle p2"></div>
                    <div class="preview-particle p3"></div>
                    <div class="preview-player"></div>
                </div>
                <div class="channel-title">Dodge-Grays</div>
            </div>

            <!-- Ferroxel Channel Tile (formerly VoxelCraft) -->
            <div class="channel-tile active-game" data-game="ferroxel">
                <div class="channel-preview">
                    <div class="ferroxel-preview">
                        <div class="ferroxel-cube grass"></div>
                        <div class="ferroxel-cube dirt"></div>
                        <div class="ferroxel-cube stone"></div>
                        <div class="ferroxel-cube wood"></div>
                    </div>
                </div>
                <div class="channel-title">Ferroxel</div>
            </div>

            <!-- Placeholder Channel Tiles -->
            <div class="channel-tile placeholder" data-game="coming-soon">
                <div class="channel-preview placeholder-preview"></div>
                <div class="channel-title">Coming Soon</div>
            </div>

            <div class="channel-tile placeholder" data-game="coming-soon">
                <div class="channel-preview placeholder-preview"></div>
                <div class="channel-title">Coming Soon</div>
            </div>

            <div class="channel-tile placeholder" data-game="coming-soon">
                <div class="channel-preview placeholder-preview"></div>
                <div class="channel-title">Coming Soon</div>
            </div>

            <div class="channel-tile placeholder" data-game="coming-soon">
                <div class="channel-preview placeholder-preview"></div>
                <div class="channel-title">Coming Soon</div>
            </div>

            <div class="channel-tile placeholder" data-game="coming-soon">
                <div class="channel-preview placeholder-preview"></div>
                <div class="channel-title">Coming Soon</div>
            </div>

            <div class="channel-tile placeholder" data-game="coming-soon">
                <div class="channel-preview placeholder-preview"></div>
                <div class="channel-title">Coming Soon</div>
            </div>
        </div>
    </div>

    <!-- Game Modal -->
    <div class="game-modal" id="gameModal">
        <div class="modal-content">
            <button class="modal-close" id="modalClose">×</button>
            
            <!-- Dodge-Grays Game Content -->
            <div class="game-card" id="particleCard">
                <div class="game-header">
                    <div class="game-title">
                        <h2>Dodge-Grays</h2>
                    </div>
                </div>

                <p class="game-description">
                    Navigate through a field of dangerous particles! Use arrow keys or on-screen controls to avoid 
                    the red particles while collecting green power-ups. Can you survive and achieve the highest score?
                </p>

                <!-- Game Controls -->
                <div class="game-controls">
                    <button class="game-button start" id="dodgeStartButton">Start Game</button>
                    <button class="game-button reset" id="dodgeResetButton">Reset Game</button>
                </div>

                <div class="game-stats">
                    <div class="stat-box">
                        <div class="stat-label">Score</div>
                        <div class="stat-value" id="particleScore">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Lives</div>
                        <div class="stat-value" id="particleLives">3</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Level</div>
                        <div class="stat-value" id="particleLevel">1</div>
                    </div>
                </div>

                <div class="lives-display" id="livesDisplay">
                    <div class="life-icon"></div>
                    <div class="life-icon"></div>
                    <div class="life-icon"></div>
                </div>

                <div class="canvas-container">
                    <canvas id="particleGame" width="600" height="400"></canvas>
                    <div class="game-message" id="particleMessage"></div>
                </div>

                <div class="mobile-controls" id="mobileControls">
                    <button class="up">↑</button>
                    <button class="down">↓</button>
                    <button class="left">←</button>
                    <button class="right">→</button>
                </div>
            </div>

            <!-- Ferroxel Game Content (formerly VoxelCraft) -->
            <div class="game-card" id="ferroxelCard" style="display: none;">
                <div class="game-header">
                    <div class="game-title">
                        <h2>Ferroxel</h2>
                    </div>
                </div>

                <p class="game-description">
                    Ferroset's Mini Minecraft/Luanti Clone.
                </p>

                <div class="canvas-container">
                    <!-- Ferroxel Start Screen -->
                    <div id="ferroxelStartScreen">
                        <div class="ferroxel-title-container">
                            <h1>FERROXEL</h1>
                            <div class="subtitle">FERROSET'S MINI MINECRAFT/LUANTI CLONE</div>
                        </div>
                        <button id="ferroxelStartButton">START GAME</button>
                    </div>
                    
                    <div id="ferroxelErrorMessage"></div>
                    
                    <canvas id="ferroxelCanvas"></canvas>
                    
                    <div id="ferroxelUI">
                        <div id="ferroxelCrosshair"></div>
                        <div id="ferroxelControls">
                            <h3>CONTROLS</h3>
                            <div style="color: #FFD700; margin-bottom: 10px;">Click game to enable mouse look</div>
                            <div>WASD - Move</div>
                            <div>SPACE - Jump</div>
                            <div>SHIFT - Sprint</div>
                            <div>Mouse - Look Around</div>
                            <div>Left Click - Break Block</div>
                            <div>Right Click - Place Block</div>
                            <div>1-6 - Select Block</div>
                        </div>
                        <div id="ferroxelFPS">FPS: 0</div>
                        <div id="ferroxelInventory"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // =============================================
        // BUBBLY BACKGROUND EFFECT
        // =============================================
        
        function createBubbles() {
            const container = document.getElementById('bubblesContainer');
            
            function createBubble() {
                const bubble = document.createElement('div');
                bubble.className = 'bubble';
                
                // Random size between 3px and 12px
                const size = Math.random() * 9 + 3;
                bubble.style.width = size + 'px';
                bubble.style.height = size + 'px';
                
                // Random horizontal position
                bubble.style.left = Math.random() * 100 + '%';
                
                // Random duration between 8s and 15s
                const duration = Math.random() * 7 + 8;
                bubble.style.animationDuration = duration + 's';
                
                // Random delay to stagger bubbles
                const delay = Math.random() * 5;
                bubble.style.animationDelay = delay + 's';
                
                container.appendChild(bubble);
                
                // Remove bubble after animation completes
                setTimeout(() => {
                    bubble.remove();
                }, (duration + delay) * 1000);
            }
            
            // Create initial bubbles
            for (let i = 0; i < 30; i++) {
                setTimeout(() => createBubble(), Math.random() * 5000);
            }
            
            // Continuously create new bubbles
            setInterval(() => {
                createBubble();
            }, 800);
        }

        // =============================================
        // SPLASH SCREEN FUNCTIONALITY
        // =============================================
        
        function initSplashScreen() {
            const splashScreen = document.getElementById('splashScreen');
            const mainContent = document.getElementById('mainContent');
            const loadingProgress = document.getElementById('loadingProgress');

            let progress = 0;

            const loadingInterval = setInterval(() => {
                progress += Math.random() * 15 + 5;
                
                if (progress >= 100) {
                    progress = 100;
                    clearInterval(loadingInterval);
                    
                    loadingProgress.style.width = '100%';
                    
                    setTimeout(() => {
                        splashScreen.classList.add('fade-out');
                        setTimeout(() => {
                            splashScreen.style.display = 'none';
                            mainContent.classList.add('visible');
                        }, 600);
                    }, 500);
                } else {
                    loadingProgress.style.width = progress + '%';
                }
            }, 200);
        }

        // =============================================
        // MODAL FUNCTIONALITY
        // =============================================

        const gameModal = document.getElementById('gameModal');
        const modalClose = document.getElementById('modalClose');
        const channelTiles = document.querySelectorAll('.channel-tile');

        // Open modal when channel tile is clicked
        channelTiles.forEach(tile => {
            tile.addEventListener('click', () => {
                const gameType = tile.getAttribute('data-game');
                
                // Don't open modal for placeholder tiles
                if (tile.classList.contains('placeholder')) {
                    return;
                }
                
                if (gameType === 'dodge-grays') {
                    document.getElementById('particleCard').style.display = 'block';
                    document.getElementById('ferroxelCard').style.display = 'none';
                    gameModal.classList.add('active');
                    document.body.style.overflow = 'hidden';
                } else if (gameType === 'ferroxel') {
                    document.getElementById('particleCard').style.display = 'none';
                    document.getElementById('ferroxelCard').style.display = 'block';
                    gameModal.classList.add('active');
                    document.body.style.overflow = 'hidden';
                    
                    // Initialize Ferroxel if not already initialized
                    if (!window.ferroxelGameInitialized) {
                        initFerroxel();
                        window.ferroxelGameInitialized = true;
                    }
                }
            });
        });

        // Close modal
        function closeModal() {
            gameModal.classList.remove('active');
            document.body.style.overflow = 'auto';
            // Reset games when closing
            if (typeof DodgeGame !== 'undefined') {
                DodgeGame.stop();
            }
            if (typeof FerroxelGame !== 'undefined') {
                FerroxelGame.stop();
            }
        }

        modalClose.addEventListener('click', closeModal);

        // Close modal when clicking outside content
        gameModal.addEventListener('click', (e) => {
            if (e.target === gameModal) {
                closeModal();
            }
        });

        // Close modal with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && gameModal.classList.contains('active')) {
                closeModal();
            }
        });

        // =============================================
        // GAME STATE MANAGEMENT
        // =============================================

        const GameState = {
            keys: {},
            animationIds: new Set(),
            intervals: new Set()
        };

        function cleanupAnimations() {
            GameState.animationIds.forEach(id => cancelAnimationFrame(id));
            GameState.intervals.forEach(id => clearInterval(id));
            GameState.animationIds.clear();
            GameState.intervals.clear();
        }

        // =============================================
        // DOM REFERENCES
        // =============================================

        const DOM = {
            particleGame: document.getElementById('particleGame'),
            particleScore: document.getElementById('particleScore'),
            particleLives: document.getElementById('particleLives'),
            particleLevel: document.getElementById('particleLevel'),
            particleMessage: document.getElementById('particleMessage'),
            livesDisplay: document.getElementById('livesDisplay'),
            mobileControls: document.getElementById('mobileControls'),
            dodgeStartButton: document.getElementById('dodgeStartButton'),
            dodgeResetButton: document.getElementById('dodgeResetButton'),
            ferroxelCanvas: document.getElementById('ferroxelCanvas'),
            ferroxelStartScreen: document.getElementById('ferroxelStartScreen'),
            ferroxelStartButton: document.getElementById('ferroxelStartButton')
        };

        // =============================================
        // UTILITY FUNCTIONS
        // =============================================

        function showGameMessage(element, message, type = 'success', duration = 2000) {
            element.textContent = message;
            element.className = `game-message visible ${type}`;
            
            setTimeout(() => {
                element.classList.remove('visible');
            }, duration);
        }

        function updateLivesDisplay() {
            const lifeIcons = DOM.livesDisplay.querySelectorAll('.life-icon');
            lifeIcons.forEach((icon, index) => {
                if (index >= parseInt(DOM.particleLives.textContent)) {
                    icon.classList.add('lost');
                } else {
                    icon.classList.remove('lost');
                }
            });
        }

        // =============================================
        // PARTICLE DODGE GAME
        // =============================================

        const DodgeGame = (function() {
            const canvas = DOM.particleGame;
            const ctx = canvas.getContext('2d');

            // Game constants
            const CONSTANTS = {
                PLAYER_SIZE: 15,
                PLAYER_SPEED: 5,
                PARTICLE_MIN_SIZE: 3,
                PARTICLE_MAX_SIZE: 12,
                PARTICLE_SIZE: 8,
                PARTICLE_BASE_SPEED: 2,
                INITIAL_PARTICLE_COUNT: 5,
                POWERUP_SIZE: 12,
                POWERUP_SPAWN_CHANCE: 0.003,
                SCORE_INCREMENT: 1,
                SCORE_INTERVAL: 100,
                LEVEL_THRESHOLD: 1000,
                MAX_LIVES: 3
            };

            // Game state
            const state = {
                player: { x: 0, y: 0, size: CONSTANTS.PLAYER_SIZE },
                particles: [],
                powerups: [],
                debris: [],
                score: 0,
                lives: CONSTANTS.MAX_LIVES,
                level: 1,
                gameRunning: false,
                isGameOver: false,
                gameOverTime: 0,
                lastTime: 0,
                scoreMultiplier: 1,
                isInvulnerable: false,
                invulnerabilityTimer: 0,
                animationId: null,
                scoreIntervalId: null
            };

            /**
             * Initialize the game
             */
            function init() {
                state.player.x = canvas.width / 2;
                state.player.y = canvas.height / 2;
                state.particles = [];
                state.powerups = [];
                state.debris = [];
                state.score = 0;
                state.lives = CONSTANTS.MAX_LIVES;
                state.level = 1;
                state.scoreMultiplier = 1;
                state.isInvulnerable = false;
                state.invulnerabilityTimer = 0;

                DOM.particleScore.textContent = '0';
                DOM.particleLives.textContent = CONSTANTS.MAX_LIVES;
                DOM.particleLevel.textContent = '1';
                updateLivesDisplay();

                for (let i = 0; i < CONSTANTS.INITIAL_PARTICLE_COUNT; i++) {
                    createParticle();
                }

                draw();
            }

            /**
             * Create a new particle
             */
            function createParticle() {
                const size = CONSTANTS.PARTICLE_SIZE;
                const side = Math.floor(Math.random() * 4);
                let x, y, vx, vy;

                switch(side) {
                    case 0: // Top
                        x = Math.random() * canvas.width;
                        y = -size;
                        vx = (Math.random() - 0.5) * 1.2;
                        vy = Math.random() * 1.2 + 0.6;
                        break;
                    case 1: // Right
                        x = canvas.width + size;
                        y = Math.random() * canvas.height;
                        vx = -(Math.random() * 1.2 + 0.6);
                        vy = (Math.random() - 0.5) * 1.2;
                        break;
                    case 2: // Bottom
                        x = Math.random() * canvas.width;
                        y = canvas.height + size;
                        vx = (Math.random() - 0.5) * 1.2;
                        vy = -(Math.random() * 1.2 + 0.6);
                        break;
                    case 3: // Left
                        x = -size;
                        y = Math.random() * canvas.height;
                        vx = Math.random() * 1.2 + 0.6;
                        vy = (Math.random() - 0.5) * 1.2;
                        break;
                }

                const speedMultiplier = 1 + (state.level - 1) * 0.2;
                
                state.particles.push({
                    x, y,
                    vx: vx * speedMultiplier,
                    vy: vy * speedMultiplier,
                    size,
                    hue: Math.random() * 60
                });
            }

            /**
             * Create a power-up
             */
            function createPowerup() {
                state.powerups.push({
                    x: Math.random() * (canvas.width - 40) + 20,
                    y: Math.random() * (canvas.height - 40) + 20,
                    size: CONSTANTS.POWERUP_SIZE,
                    type: Math.random() < 0.5 ? 'shield' : 'multiplier',
                    lifetime: 0,
                    maxLifetime: 5000
                });
            }

            /**
             * Create explosion effect - FIXED: Removed syntax error
             */
            function createExplosion(x, y) {
                for (let i = 0; i < 20; i++) {
                    const angle = (Math.PI * 2 * i) / 20;
                    const speed = Math.random() * 3 + 2;
                    state.debris.push({
                        x, y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed, // FIXED: Removed extra equals sign
                        size: Math.random() * 4 + 2,
                        alpha: 1,
                        decay: 0.02
                    });
                }
            }

            /**
             * Update game state
             */
            function update(currentTime) {
                if (!state.gameRunning) return;

                const deltaTime = state.lastTime ? (currentTime - state.lastTime) / 1000 : 0;
                state.lastTime = currentTime;

                if (state.isGameOver) {
                    state.gameOverTime += deltaTime;
                    updateDebris(deltaTime);
                    
                    if (state.gameOverTime > 2) {
                        state.gameRunning = false;
                        showGameMessage(DOM.particleMessage, `GAME OVER! Final Score: ${state.score}`, 'error', 3000);
                    }
                } else {
                    updatePlayer(deltaTime);
                    updateParticles(deltaTime);
                    updatePowerups(deltaTime);
                    updateDebris(deltaTime);
                    checkCollisions();
                    updateLevel();

                    if (Math.random() < CONSTANTS.POWERUP_SPAWN_CHANCE) {
                        createPowerup();
                    }
                }

                draw();
                state.animationId = requestAnimationFrame(update);
            }

            /**
             * Update player position
             */
            function updatePlayer(deltaTime) {
                const speed = CONSTANTS.PLAYER_SPEED;
                
                if (GameState.keys['ArrowUp'] || GameState.keys['w'] || GameState.keys['W'] || GameState.keys['up']) {
                    state.player.y = Math.max(state.player.size, state.player.y - speed);
                }
                if (GameState.keys['ArrowDown'] || GameState.keys['s'] || GameState.keys['S'] || GameState.keys['down']) {
                    state.player.y = Math.min(canvas.height - state.player.size, state.player.y + speed);
                }
                if (GameState.keys['ArrowLeft'] || GameState.keys['a'] || GameState.keys['A'] || GameState.keys['left']) {
                    state.player.x = Math.max(state.player.size, state.player.x - speed);
                }
                if (GameState.keys['ArrowRight'] || GameState.keys['d'] || GameState.keys['D'] || GameState.keys['right']) {
                    state.player.x = Math.min(canvas.width - state.player.size, state.player.x + speed);
                }

                if (state.isInvulnerable) {
                    state.invulnerabilityTimer -= deltaTime;
                    if (state.invulnerabilityTimer <= 0) {
                        state.isInvulnerable = false;
                    }
                }
            }

            /**
             * Update particles
             */
            function updateParticles(deltaTime) {
                for (let i = state.particles.length - 1; i >= 0; i--) {
                    const p = state.particles[i];
                    p.x += p.vx;
                    p.y += p.vy;

                    if (p.x < -p.size || p.x > canvas.width + p.size ||
                        p.y < -p.size || p.y > canvas.height + p.size) {
                        state.particles.splice(i, 1);
                        createParticle();
                    }
                }
            }

            /**
             * Update power-ups
             */
            function updatePowerups(deltaTime) {
                for (let i = state.powerups.length - 1; i >= 0; i--) {
                    const powerup = state.powerups[i];
                    powerup.lifetime += deltaTime * 1000;

                    if (powerup.lifetime > powerup.maxLifetime) {
                        state.powerups.splice(i, 1);
                    }
                }
            }

            /**
             * Update debris particles
             */
            function updateDebris(deltaTime) {
                for (let i = state.debris.length - 1; i >= 0; i--) {
                    const debris = state.debris[i];
                    debris.x += debris.vx;
                    debris.y += debris.vy;
                    debris.alpha -= debris.decay;
                    
                    if (debris.alpha <= 0) {
                        state.debris.splice(i, 1);
                    }
                }
            }

            /**
             * Check for collisions
             */
            function checkCollisions() {
                // Check particle collisions (always, even when invulnerable)
                for (let i = state.particles.length - 1; i >= 0; i--) {
                    const particle = state.particles[i];
                    const dx = state.player.x - particle.x;
                    const dy = state.player.y - particle.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < state.player.size + particle.size) {
                        // Create explosion at particle location
                        createExplosion(particle.x, particle.y);
                        
                        // Remove the particle
                        state.particles.splice(i, 1);
                        
                        // Create a new particle to replace it
                        createParticle();
                        
                        // Only damage player if not invulnerable
                        if (!state.isInvulnerable) {
                            playerHit();
                        }
                    }
                }

                for (let i = state.powerups.length - 1; i >= 0; i--) {
                    const powerup = state.powerups[i];
                    const dx = state.player.x - powerup.x;
                    const dy = state.player.y - powerup.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < state.player.size + powerup.size) {
                        if (powerup.type === 'shield') {
                            state.isInvulnerable = true;
                            state.invulnerabilityTimer = 3.0;
                            showGameMessage(DOM.particleMessage, 'SHIELD ACTIVATED!', 'success', 1500);
                        } else {
                            state.scoreMultiplier = 2;
                            setTimeout(() => { state.scoreMultiplier = 1; }, 5000);
                            showGameMessage(DOM.particleMessage, '2X SCORE MULTIPLIER!', 'success', 1500);
                        }
                        state.powerups.splice(i, 1);
                    }
                }
            }

            /**
             * Update game level
             */
            function updateLevel() {
                const newLevel = Math.floor(state.score / CONSTANTS.LEVEL_THRESHOLD) + 1;
                if (newLevel > state.level) {
                    state.level = newLevel;
                    DOM.particleLevel.textContent = state.level;
                    showGameMessage(DOM.particleMessage, `LEVEL ${state.level}!`, 'success', 2000);

                    const particlesToAdd = Math.min(2, Math.floor(state.level / 2));
                    for (let i = 0; i < particlesToAdd; i++) {
                        createParticle();
                    }
                }
            }

            /**
             * Draw everything
             */
            function draw() {
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw particles
                for (let particle of state.particles) {
                    const gradient = ctx.createRadialGradient(
                        particle.x, particle.y, 0,
                        particle.x, particle.y, particle.size
                    );
                    gradient.addColorStop(0, 'rgba(180, 180, 180, 1)');
                    gradient.addColorStop(1, 'rgba(140, 140, 140, 0)');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw power-ups
                for (let powerup of state.powerups) {
                    const alpha = 1 - (powerup.lifetime / powerup.maxLifetime);
                    const pulse = Math.sin(powerup.lifetime / 200) * 0.2 + 0.8;
                    const size = powerup.size * pulse;
                    
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    
                    if (powerup.type === 'shield') {
                        ctx.fillStyle = `rgba(100, 200, 255, ${pulse})`;
                        ctx.strokeStyle = `rgba(150, 220, 255, ${pulse})`;
                    } else {
                        ctx.fillStyle = `rgba(255, 215, 0, ${pulse})`;
                        ctx.strokeStyle = `rgba(255, 235, 100, ${pulse})`;
                    }
                    
                    ctx.lineWidth = 2;
                    
                    // Draw diamond shape
                    ctx.beginPath();
                    ctx.moveTo(powerup.x, powerup.y - size);           // Top point
                    ctx.lineTo(powerup.x + size, powerup.y);           // Right point
                    ctx.lineTo(powerup.x, powerup.y + size);           // Bottom point
                    ctx.lineTo(powerup.x - size, powerup.y);           // Left point
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.restore();
                }

                // Draw debris
                for (let debris of state.debris) {
                    ctx.save();
                    ctx.globalAlpha = debris.alpha;
                    ctx.fillStyle = 'rgba(180, 180, 180, 1)';
                    ctx.beginPath();
                    ctx.arc(debris.x, debris.y, debris.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }

                // Draw player
                if (!state.isGameOver) {
                    ctx.save();
                    
                    if (state.isInvulnerable) {
                        ctx.globalAlpha = Math.sin(Date.now() / 100) * 0.5 + 0.5;
                    }
                    
                    const playerGradient = ctx.createRadialGradient(
                        state.player.x, state.player.y, 0,
                        state.player.x, state.player.y, state.player.size
                    );
                    
                    if (state.isInvulnerable) {
                        playerGradient.addColorStop(0, 'rgba(100, 200, 255, 1)');
                        playerGradient.addColorStop(1, 'rgba(50, 150, 255, 0.3)');
                    } else {
                        playerGradient.addColorStop(0, 'rgba(255, 107, 107, 1)');
                        playerGradient.addColorStop(1, 'rgba(220, 70, 70, 0.3)');
                    }

                    ctx.fillStyle = playerGradient;
                    ctx.beginPath();
                    ctx.arc(state.player.x, state.player.y, state.player.size, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = state.isInvulnerable ? 'rgba(100, 200, 255, 0.8)' : 'rgba(255, 107, 107, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    ctx.restore();
                }
            }

            /**
             * Handle player being hit
             */
            function playerHit() {
                state.lives--;
                DOM.particleLives.textContent = state.lives;
                updateLivesDisplay();
                
                if (state.lives <= 0) {
                    createExplosion(state.player.x, state.player.y);
                    state.isGameOver = true;
                    state.gameOverTime = 0;
                } else {
                    state.isInvulnerable = true;
                    state.invulnerabilityTimer = 2.0;
                    showGameMessage(DOM.particleMessage, `HIT! LIVES: ${state.lives}`, 'warning', 1000);
                }
            }

            /**
             * Start the game
             */
            function start() {
                if (state.gameRunning) return;

                state.gameRunning = true;
                state.isGameOver = false;
                state.lastTime = 0;

                if (state.animationId) {
                    cancelAnimationFrame(state.animationId);
                    state.animationId = null;
                }

                if (state.scoreIntervalId) {
                    clearInterval(state.scoreIntervalId);
                    state.scoreIntervalId = null;
                }

                state.animationId = requestAnimationFrame(update);
                GameState.animationIds.add(state.animationId);

                state.scoreIntervalId = setInterval(() => {
                    if (state.gameRunning && !state.isGameOver) {
                        state.score += CONSTANTS.SCORE_INCREMENT * state.scoreMultiplier;
                        DOM.particleScore.textContent = state.score;
                    }
                }, CONSTANTS.SCORE_INTERVAL);

                GameState.intervals.add(state.scoreIntervalId);
            }

            /**
             * Reset the game
             */
            function reset() {
                state.gameRunning = false;
                state.isGameOver = false;
                
                if (state.animationId) {
                    cancelAnimationFrame(state.animationId);
                    state.animationId = null;
                }
                
                if (state.scoreIntervalId) {
                    clearInterval(state.scoreIntervalId);
                    state.scoreIntervalId = null;
                }
                
                init();
            }

            /**
             * Stop the game
             */
            function stop() {
                state.gameRunning = false;
                
                if (state.animationId) {
                    cancelAnimationFrame(state.animationId);
                    state.animationId = null;
                }
                
                if (state.scoreIntervalId) {
                    clearInterval(state.scoreIntervalId);
                    state.scoreIntervalId = null;
                }
            }

            // Initialize the game but don't start it automatically
            init();

            return {
                start,
                reset,
                stop,
                init
            };
        })();

        // =============================================
        // FERROXEL GAME (formerly VoxelCraft)
        // =============================================

        let FerroxelGame = null;

        function initFerroxel() {
            FerroxelGame = (function() {
                // Global game variables
                let gameState = {
                    initialized: false,
                    running: false,
                    scene: null,
                    camera: null,
                    renderer: null,
                    world: new Map(),
                    blockMeshes: new Map(),
                    particles: [],
                    clock: null,
                    raycaster: null,
                    frameCount: 0,
                    lastTime: performance.now(),
                    isPointerLocked: false,
                    selectedBlockType: 1,
                    keys: {},
                    player: {
                        position: { x: 25, y: 20, z: 25 },
                        velocity: { x: 0, y: 0, z: 0 },
                        rotation: { x: 0, y: 0 },
                        onGround: false
                    },
                    inventoryInitialized: false // Track if inventory is already set up
                };
                
                // Game constants
                const WORLD_SIZE = 30; // Reduced for better performance
                const BLOCK_SIZE = 1;
                const GRAVITY = -20;
                const JUMP_VELOCITY = 10;
                const PLAYER_HEIGHT = 1.8;
                const PLAYER_SPEED = 5;
                const SPRINT_MULTIPLIER = 1.8;
                
                // Block types
                const BlockType = {
                    AIR: 0,
                    GRASS: 1,
                    DIRT: 2,
                    STONE: 3,
                    WOOD: 4,
                    LEAVES: 5,
                    SAND: 6
                };
                
                // Block colors
                const blockColors = {
                    [BlockType.GRASS]: 0x3A7D00,
                    [BlockType.DIRT]: 0x8B4513,
                    [BlockType.STONE]: 0x808080,
                    [BlockType.WOOD]: 0x654321,
                    [BlockType.LEAVES]: 0x228B22,
                    [BlockType.SAND]: 0xF4A460
                };
                
                // Simple terrain noise function
                function terrainNoise(x, z) {
                    const height = 10 + 
                        Math.sin(x * 0.1) * 3 + 
                        Math.cos(z * 0.1) * 3 + 
                        Math.sin((x + z) * 0.05) * 2;
                    return Math.floor(height);
                }
                
                // Initialize Three.js
                function initThreeJS() {
                    try {
                        // Get canvas container
                        const canvasContainer = DOM.ferroxelCanvas.parentElement;
                        
                        // Scene
                        gameState.scene = new THREE.Scene();
                        gameState.scene.fog = new THREE.Fog(0x87CEEB, 10, 100);
                        
                        // Camera
                        gameState.camera = new THREE.PerspectiveCamera(
                            75, 
                            canvasContainer.clientWidth / canvasContainer.clientHeight, 
                            0.1, 
                            100
                        ); // Reduced far plane for performance
                        gameState.camera.position.set(
                            gameState.player.position.x,
                            gameState.player.position.y,
                            gameState.player.position.z
                        );
                        
                        // Renderer with performance optimizations
                        gameState.renderer = new THREE.WebGLRenderer({ 
                            canvas: DOM.ferroxelCanvas,
                            antialias: false, // Disabled for performance
                            powerPreference: "high-performance"
                        });
                        gameState.renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
                        gameState.renderer.shadowMap.enabled = false; // Disabled for performance
                        gameState.renderer.setClearColor(0x87CEEB); // FIX: Set clear color to light blue
                        
                        // Lights
                        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                        gameState.scene.add(ambientLight);
                        
                        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                        directionalLight.position.set(50, 100, 50);
                        gameState.scene.add(directionalLight);
                        
                        // Sky - FIXED: Changed to light blue
                        const skyGeometry = new THREE.SphereGeometry(200, 16, 16); // Reduced detail
                        const skyMaterial = new THREE.MeshBasicMaterial({
                            color: 0x87CEEB, // FIX: Changed to light blue
                            side: THREE.BackSide
                        });
                        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
                        gameState.scene.add(sky);
                        
                        // Utilities
                        gameState.clock = new THREE.Clock();
                        gameState.raycaster = new THREE.Raycaster();
                        
                        return true;
                    } catch (error) {
                        console.error('Failed to initialize Three.js:', error);
                        return false;
                    }
                }
                
                // Generate world
                function generateWorld() {
                    const boxGeometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                    
                    for (let x = 0; x < WORLD_SIZE; x++) {
                        for (let z = 0; z < WORLD_SIZE; z++) {
                            const height = terrainNoise(x, z);
                            
                            for (let y = 0; y < height; y++) {
                                let blockType;
                                if (y === height - 1) {
                                    blockType = BlockType.GRASS;
                                } else if (y > height - 4) {
                                    blockType = BlockType.DIRT;
                                } else {
                                    blockType = BlockType.STONE;
                                }
                                
                                const key = `${x},${y},${z}`;
                                gameState.world.set(key, blockType);
                                
                                // Create mesh
                                const material = new THREE.MeshLambertMaterial({ 
                                    color: blockColors[blockType]
                                });
                                const mesh = new THREE.Mesh(boxGeometry, material);
                                mesh.position.set(x, y, z);
                                gameState.scene.add(mesh);
                                gameState.blockMeshes.set(key, mesh);
                            }
                            
                            // Add trees randomly (reduced frequency for performance)
                            if (Math.random() < 0.005 && gameState.world.get(`${x},${height - 1},${z}`) === BlockType.GRASS) {
                                generateTree(x, height, z);
                            }
                        }
                    }
                }
                
                // Generate tree
                function generateTree(x, y, z) {
                    const boxGeometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                    
                    // Trunk
                    for (let i = 0; i < 4; i++) { // Reduced height for performance
                        const key = `${x},${y + i},${z}`;
                        gameState.world.set(key, BlockType.WOOD);
                        
                        const material = new THREE.MeshLambertMaterial({ 
                            color: blockColors[BlockType.WOOD]
                        });
                        const mesh = new THREE.Mesh(boxGeometry, material);
                        mesh.position.set(x, y + i, z);
                        gameState.scene.add(mesh);
                        gameState.blockMeshes.set(key, mesh);
                    }
                    
                    // Leaves (simplified and reduced)
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = 2; dy <= 4; dy++) { // Reduced height
                            for (let dz = -1; dz <= 1; dz++) {
                                if (dx === 0 && dz === 0 && dy < 4) continue;
                                
                                const key = `${x + dx},${y + dy},${z + dz}`;
                                if (!gameState.world.has(key)) {
                                    gameState.world.set(key, BlockType.LEAVES);
                                    
                                    const material = new THREE.MeshLambertMaterial({ 
                                        color: blockColors[BlockType.LEAVES],
                                        transparent: true,
                                        opacity: 0.9
                                    });
                                    const mesh = new THREE.Mesh(boxGeometry, material);
                                    mesh.position.set(x + dx, y + dy, z + dz);
                                    gameState.scene.add(mesh);
                                    gameState.blockMeshes.set(key, mesh);
                                }
                            }
                        }
                    }
                }
                
                // Setup inventory UI - FIXED: Prevent duplication
                function setupInventory() {
                    // Only set up inventory once
                    if (gameState.inventoryInitialized) return;
                    
                    const inventory = document.getElementById('ferroxelInventory');
                    const blockTypes = [
                        { type: BlockType.GRASS, name: 'Grass', color: '#3A7D00' },
                        { type: BlockType.DIRT, name: 'Dirt', color: '#8B4513' },
                        { type: BlockType.STONE, name: 'Stone', color: '#808080' },
                        { type: BlockType.WOOD, name: 'Wood', color: '#654321' },
                        { type: BlockType.LEAVES, name: 'Leaves', color: '#228B22' },
                        { type: BlockType.SAND, name: 'Sand', color: '#F4A460' }
                    ];
                    
                    blockTypes.forEach((block, index) => {
                        const slot = document.createElement('div');
                        slot.className = 'ferroxel-inventory-slot';
                        if (index === 0) slot.classList.add('active');
                        
                        const preview = document.createElement('div');
                        preview.className = 'ferroxel-block-preview';
                        preview.style.backgroundColor = block.color;
                        
                        slot.appendChild(preview);
                        slot.addEventListener('click', () => {
                            document.querySelectorAll('.ferroxel-inventory-slot').forEach(s => s.classList.remove('active'));
                            slot.classList.add('active');
                            gameState.selectedBlockType = block.type;
                        });
                        
                        inventory.appendChild(slot);
                    });
                    
                    gameState.inventoryInitialized = true; // Mark as initialized
                }
                
                // Create particles for block breaking (optimized)
                function createBlockParticles(x, y, z, blockType) {
                    const particleGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                    const particleMaterial = new THREE.MeshLambertMaterial({ 
                        color: blockColors[blockType] 
                    });
                    
                    // Create fewer particles for performance
                    for (let i = 0; i < 4; i++) { // Reduced from 8 to 4
                        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                        
                        // Position at the block center with slight offset
                        particle.position.set(
                            x + 0.5 + (Math.random() - 0.5) * 0.2,
                            y + 0.5 + (Math.random() - 0.5) * 0.2,
                            z + 0.5 + (Math.random() - 0.5) * 0.2
                        );
                        
                        // Random velocity
                        const velocity = {
                            x: (Math.random() - 0.5) * 5,
                            y: Math.random() * 3 + 2,
                            z: (Math.random() - 0.5) * 5
                        };
                        
                        // Random rotation
                        const rotationSpeed = {
                            x: (Math.random() - 0.5) * 0.2,
                            y: (Math.random() - 0.5) * 0.2,
                            z: (Math.random() - 0.5) * 0.2
                        };
                        
                        // Shorter lifetime
                        const lifetime = 0.8 + Math.random() * 0.3; // Reduced from 1-1.5 to 0.8-1.1
                        
                        gameState.scene.add(particle);
                        gameState.particles.push({
                            mesh: particle,
                            velocity: velocity,
                            rotationSpeed: rotationSpeed,
                            lifetime: lifetime,
                            maxLifetime: lifetime
                        });
                    }
                }
                
                // Update particles
                function updateParticles(deltaTime) {
                    for (let i = gameState.particles.length - 1; i >= 0; i--) {
                        const particle = gameState.particles[i];
                        
                        // Update position
                        particle.mesh.position.x += particle.velocity.x * deltaTime;
                        particle.mesh.position.y += particle.velocity.y * deltaTime;
                        particle.mesh.position.z += particle.velocity.z * deltaTime;
                        
                        // Apply gravity
                        particle.velocity.y += GRAVITY * deltaTime;
                        
                        // Update rotation
                        particle.mesh.rotation.x += particle.rotationSpeed.x;
                        particle.mesh.rotation.y += particle.rotationSpeed.y;
                        particle.mesh.rotation.z += particle.rotationSpeed.z;
                        
                        // Update lifetime
                        particle.lifetime -= deltaTime;
                        
                        // Fade out
                        const opacity = particle.lifetime / particle.maxLifetime;
                        particle.mesh.material.opacity = opacity;
                        
                        // Remove dead particles
                        if (particle.lifetime <= 0) {
                            gameState.scene.remove(particle.mesh);
                            gameState.particles.splice(i, 1);
                        }
                    }
                }
                
                // Setup event listeners
                function setupEventListeners() {
                    // Keyboard
                    document.addEventListener('keydown', (e) => {
                        // Prevent space bar from triggering multiple events
                        if (e.code === 'Space') {
                            e.preventDefault();
                        }
                        
                        gameState.keys[e.code] = true;
                        
                        // Number keys for block selection
                        if (e.code >= 'Digit1' && e.code <= 'Digit6') {
                            const index = parseInt(e.code.replace('Digit', '')) - 1;
                            const slots = document.querySelectorAll('.ferroxel-inventory-slot');
                            if (slots[index]) {
                                slots.forEach(s => s.classList.remove('active'));
                                slots[index].classList.add('active');
                                const blockTypeArray = [BlockType.GRASS, BlockType.DIRT, BlockType.STONE, BlockType.WOOD, BlockType.LEAVES, BlockType.SAND];
                                gameState.selectedBlockType = blockTypeArray[index];
                            }
                        }
                    });
                    
                    document.addEventListener('keyup', (e) => {
                        gameState.keys[e.code] = false;
                    });
                    
                    // Mouse movement
                    document.addEventListener('mousemove', (e) => {
                        if (!gameState.isPointerLocked) return;
                        
                        const movementX = e.movementX || e.mozMovementX || e.webkitMovementX || 0;
                        const movementY = e.movementY || e.mozMovementY || e.webkitMovementY || 0;
                        
                        // Apply rotation with proper FPS camera controls
                        gameState.player.rotation.y -= movementX * 0.002;
                        gameState.player.rotation.x -= movementY * 0.002;
                        
                        // Clamp vertical rotation to prevent flipping
                        gameState.player.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, gameState.player.rotation.x));
                    });
                    
                    // Click for pointer lock
                    DOM.ferroxelCanvas.addEventListener('click', () => {
                        if (!gameState.isPointerLocked && gameState.running) {
                            const canvas = DOM.ferroxelCanvas;
                            canvas.requestPointerLock = canvas.requestPointerLock || 
                                                       canvas.mozRequestPointerLock || 
                                                       canvas.webkitRequestPointerLock;
                            if (canvas.requestPointerLock) {
                                canvas.requestPointerLock();
                            }
                        }
                    });
                    
                    // Mouse buttons
                    document.addEventListener('mousedown', (e) => {
                        if (!gameState.isPointerLocked || !gameState.running) return;
                        
                        if (e.button === 0) {
                            breakBlock();
                        } else if (e.button === 2) {
                            placeBlock();
                        }
                    });
                    
                    document.addEventListener('contextmenu', (e) => e.preventDefault());
                    
                    // Pointer lock change
                    function handlePointerLockChange() {
                        const canvas = DOM.ferroxelCanvas;
                        gameState.isPointerLocked = document.pointerLockElement === canvas || 
                                                   document.mozPointerLockElement === canvas || 
                                                   document.webkitPointerLockElement === canvas;
                        
                        // Show/hide crosshair based on pointer lock
                        const crosshair = document.getElementById('ferroxelCrosshair');
                        if (gameState.isPointerLocked) {
                            crosshair.classList.add('active');
                        } else {
                            crosshair.classList.remove('active');
                        }
                    }
                    
                    document.addEventListener('pointerlockchange', handlePointerLockChange);
                    document.addEventListener('mozpointerlockchange', handlePointerLockChange);
                    document.addEventListener('webkitpointerlockchange', handlePointerLockChange);
                    
                    // Window resize - handle both normal and fullscreen modes
                    function handleResize() {
                        if (gameState.camera && gameState.renderer) {
                            const canvasContainer = DOM.ferroxelCanvas.parentElement;
                            gameState.renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
                            gameState.camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
                            gameState.camera.updateProjectionMatrix();
                        }
                    }
                    
                    window.addEventListener('resize', handleResize);
                }
                
                // Get block at position
                function getBlockAt(x, y, z) {
                    const key = `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
                    return gameState.world.get(key) || BlockType.AIR;
                }
                
                // Set block at position
                function setBlockAt(x, y, z, type) {
                    const key = `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
                    
                    if (type === BlockType.AIR) {
                        gameState.world.delete(key);
                        const mesh = gameState.blockMeshes.get(key);
                        if (mesh) {
                            gameState.scene.remove(mesh);
                            gameState.blockMeshes.delete(key);
                        }
                    } else {
                        gameState.world.set(key, type);
                        
                        if (!gameState.blockMeshes.has(key)) {
                            const boxGeometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                            const material = new THREE.MeshLambertMaterial({ 
                                color: blockColors[type]
                            });
                            const mesh = new THREE.Mesh(boxGeometry, material);
                            mesh.position.set(Math.floor(x), Math.floor(y), Math.floor(z));
                            gameState.scene.add(mesh);
                            gameState.blockMeshes.set(key, mesh);
                        }
                    }
                }
                
                // Cast ray from camera
                function castRay() {
                    // Create direction vector based on camera rotation
                    const direction = new THREE.Vector3();
                    
                    // Apply rotation to direction vector
                    const euler = new THREE.Euler(
                        gameState.player.rotation.x,
                        gameState.player.rotation.y,
                        0,
                        'YXZ'
                    );
                    
                    direction.set(0, 0, -1);
                    direction.applyEuler(euler);
                    
                    gameState.raycaster.set(
                        new THREE.Vector3(
                            gameState.player.position.x,
                            gameState.player.position.y,
                            gameState.player.position.z
                        ),
                        direction
                    );
                    
                    const intersects = [];
                    gameState.blockMeshes.forEach((mesh, key) => {
                        const intersection = gameState.raycaster.intersectObject(mesh);
                        if (intersection.length > 0) {
                            intersects.push({
                                ...intersection[0],
                                key: key
                            });
                        }
                    });
                    
                    intersects.sort((a, b) => a.distance - b.distance);
                    return intersects[0] || null;
                }
                
                // Break block
                function breakBlock() {
                    const hit = castRay();
                    if (hit && hit.distance < 5) {
                        const [x, y, z] = hit.key.split(',').map(Number);
                        const blockType = gameState.world.get(hit.key);
                        
                        // Create particles before removing the block
                        createBlockParticles(x, y, z, blockType);
                        
                        setBlockAt(x, y, z, BlockType.AIR);
                    }
                }
                
                // Place block
                function placeBlock() {
                    const hit = castRay();
                    if (hit && hit.distance < 5) {
                        const normal = hit.face.normal;
                        const [x, y, z] = hit.key.split(',').map(Number);
                        const newX = x + normal.x;
                        const newY = y + normal.y;
                        const newZ = z + normal.z;
                        
                        // Check collision with player
                        const playerMinX = gameState.player.position.x - 0.3;
                        const playerMaxX = gameState.player.position.x + 0.3;
                        const playerMinY = gameState.player.position.y - PLAYER_HEIGHT / 2;
                        const playerMaxY = gameState.player.position.y + PLAYER_HEIGHT / 2;
                        const playerMinZ = gameState.player.position.z - 0.3;
                        const playerMaxZ = gameState.player.position.z + 0.3;
                        
                        const blockMinX = newX - 0.5;
                        const blockMaxX = newX + 0.5;
                        const blockMinY = newY - 0.5;
                        const blockMaxY = newY + 0.5;
                        const blockMinZ = newZ - 0.5;
                        const blockMaxZ = newZ + 0.5;
                        
                        const collides = !(playerMaxX < blockMinX || playerMinX > blockMaxX ||
                                          playerMaxY < blockMinY || playerMinY > blockMaxY ||
                                          playerMaxZ < blockMinZ || playerMinZ > blockMaxZ);
                        
                        if (!collides) {
                            setBlockAt(newX, newY, newZ, gameState.selectedBlockType);
                        }
                    }
                }
                
                // Check collision
                function checkCollision(position) {
                    const margin = 0.3;
                    const positions = [
                        [position.x - margin, position.y, position.z - margin],
                        [position.x + margin, position.y, position.z - margin],
                        [position.x - margin, position.y, position.z + margin],
                        [position.x + margin, position.y, position.z + margin],
                        [position.x, position.y - PLAYER_HEIGHT, position.z]
                    ];
                    
                    for (let pos of positions) {
                        if (getBlockAt(...pos) !== BlockType.AIR) {
                            return true;
                        }
                    }
                    return false;
                }
                
                // Update player physics
                function updatePlayer(deltaTime) {
                    if (!gameState.running) return;
                    
                    const moveSpeed = PLAYER_SPEED * (gameState.keys['ShiftLeft'] ? SPRINT_MULTIPLIER : 1);
                    
                    // Calculate movement direction
                    const forward = new THREE.Vector3();
                    const right = new THREE.Vector3();
                    
                    // Create rotation matrix from player's yaw (only y rotation for movement)
                    const euler = new THREE.Euler(0, gameState.player.rotation.y, 0, 'YXZ');
                    const matrix = new THREE.Matrix4();
                    matrix.makeRotationFromEuler(euler);
                    
                    forward.set(0, 0, -1).applyMatrix4(matrix);
                    right.set(1, 0, 0).applyMatrix4(matrix);
                    
                    const movement = new THREE.Vector3();
                    if (gameState.keys['KeyW']) movement.add(forward);
                    if (gameState.keys['KeyS']) movement.sub(forward);
                    if (gameState.keys['KeyA']) movement.sub(right);
                    if (gameState.keys['KeyD']) movement.add(right);
                    
                    if (movement.length() > 0) {
                        movement.normalize().multiplyScalar(moveSpeed * deltaTime);
                        
                        const newPosition = {
                            x: gameState.player.position.x + movement.x,
                            y: gameState.player.position.y,
                            z: gameState.player.position.z + movement.z
                        };
                        
                        if (!checkCollision(newPosition)) {
                            gameState.player.position.x = newPosition.x;
                            gameState.player.position.z = newPosition.z;
                        }
                    }
                    
                    // Jumping - FIXED: Prevent multiple jumps in quick succession
                    if (gameState.keys['Space'] && gameState.player.onGround) {
                        gameState.player.velocity.y = JUMP_VELOCITY;
                        gameState.player.onGround = false;
                        // Clear the space key to prevent multiple jumps
                        gameState.keys['Space'] = false;
                    }
                    
                    // Apply gravity
                    gameState.player.velocity.y += GRAVITY * deltaTime;
                    
                    // Apply vertical velocity
                    const newY = gameState.player.position.y + gameState.player.velocity.y * deltaTime;
                    const testPosition = {
                        x: gameState.player.position.x,
                        y: newY,
                        z: gameState.player.position.z
                    };
                    
                    if (!checkCollision(testPosition)) {
                        gameState.player.position.y = newY;
                        gameState.player.onGround = false;
                    } else {
                        if (gameState.player.velocity.y < 0) {
                            gameState.player.onGround = true;
                        }
                        gameState.player.velocity.y = 0;
                    }
                    
                    // Update camera position and rotation
                    if (gameState.camera) {
                        gameState.camera.position.set(
                            gameState.player.position.x,
                            gameState.player.position.y,
                            gameState.player.position.z
                        );
                        
                        // Apply rotation using quaternion for proper FPS camera
                        const euler = new THREE.Euler(
                            gameState.player.rotation.x,
                            gameState.player.rotation.y,
                            0,
                            'YXZ'
                        );
                        
                        gameState.camera.setRotationFromEuler(euler);
                    }
                }
                
                // Animation loop
                function animate() {
                    if (!gameState.running) return;
                    
                    requestAnimationFrame(animate);
                    
                    const deltaTime = gameState.clock.getDelta();
                    
                    if (gameState.isPointerLocked) {
                        updatePlayer(deltaTime);
                    }
                    
                    // Update particles
                    updateParticles(deltaTime);
                    
                    // Update FPS
                    gameState.frameCount++;
                    const currentTime = performance.now();
                    if (currentTime >= gameState.lastTime + 1000) {
                        const fps = Math.round(gameState.frameCount * 1000 / (currentTime - gameState.lastTime));
                        document.getElementById('ferroxelFPS').textContent = `FPS: ${fps}`;
                        gameState.frameCount = 0;
                        gameState.lastTime = currentTime;
                    }
                    
                    if (gameState.renderer && gameState.scene && gameState.camera) {
                        gameState.renderer.render(gameState.scene, gameState.camera);
                    }
                }
                
                // Start game
                function start() {
                    console.log('Starting Ferroxel...');
                    
                    // Hide start screen
                    DOM.ferroxelStartScreen.classList.add('hidden');
                    
                    // Initialize Three.js
                    if (!initThreeJS()) {
                        showFerroxelError('Failed to initialize 3D engine');
                        return;
                    }
                    
                    console.log('Three.js initialized');
                    
                    // Generate world
                    generateWorld();
                    console.log('World generated');
                    
                    // Setup UI
                    setupInventory();
                    document.getElementById('ferroxelControls').classList.add('active');
                    document.getElementById('ferroxelFPS').classList.add('active');
                    document.getElementById('ferroxelInventory').classList.add('active');
                    
                    // Setup controls
                    setupEventListeners();
                    
                    // Start game loop
                    gameState.running = true;
                    gameState.initialized = true;
                    animate();
                    
                    console.log('Ferroxel started successfully!');
                }
                
                // Show error message
                function showFerroxelError(message) {
                    const errorDiv = document.getElementById('ferroxelErrorMessage');
                    errorDiv.textContent = 'Error: ' + message;
                    errorDiv.style.display = 'block';
                    setTimeout(() => {
                        errorDiv.style.display = 'none';
                    }, 5000);
                }
                
                // Stop game
                function stop() {
                    gameState.running = false;
                    
                    // Clean up Three.js resources
                    if (gameState.scene) {
                        while(gameState.scene.children.length > 0) { 
                            gameState.scene.remove(gameState.scene.children[0]); 
                        }
                    }
                    
                    if (gameState.renderer) {
                        gameState.renderer.dispose();
                    }
                    
                    // Reset UI
                    DOM.ferroxelStartScreen.classList.remove('hidden');
                    document.getElementById('ferroxelControls').classList.remove('active');
                    document.getElementById('ferroxelFPS').classList.remove('active');
                    document.getElementById('ferroxelInventory').classList.remove('active');
                    document.getElementById('ferroxelCrosshair').classList.remove('active');
                    
                    // Reset game state but preserve inventory initialization
                    const inventoryInitialized = gameState.inventoryInitialized;
                    gameState.initialized = false;
                    gameState.world.clear();
                    gameState.blockMeshes.clear();
                    gameState.particles = [];
                    gameState.isPointerLocked = false;
                    gameState.inventoryInitialized = inventoryInitialized;
                    
                    console.log('Ferroxel stopped');
                }
                
                return {
                    start,
                    stop
                };
            })();
            
            // Setup Ferroxel start button
            DOM.ferroxelStartButton.addEventListener('click', FerroxelGame.start);
        }

        // =============================================
        // EVENT LISTENERS
        // =============================================

        function initEventListeners() {
            // Keyboard input
            window.addEventListener('keydown', (e) => {
                GameState.keys[e.key] = true;
            });

            window.addEventListener('keyup', (e) => {
                GameState.keys[e.key] = false;
            });

            // Dodge-Grays Start and Reset buttons
            DOM.dodgeStartButton.addEventListener('click', () => {
                DodgeGame.start();
            });

            DOM.dodgeResetButton.addEventListener('click', () => {
                DodgeGame.reset();
            });

            // Mobile controls
            const mobileControls = DOM.mobileControls.querySelectorAll('button');
            mobileControls.forEach(button => {
                const direction = button.className;
                
                button.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    GameState.keys[direction] = true;
                });
                
                button.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    GameState.keys[direction] = false;
                });
                
                button.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    GameState.keys[direction] = true;
                });
                
                button.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    GameState.keys[direction] = false;
                });
                
                button.addEventListener('mouseleave', (e) => {
                    e.preventDefault();
                    GameState.keys[direction] = false;
                });
            });
        }

        // Initialize
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                createBubbles();
                initSplashScreen();
                initEventListeners();
            });
        } else {
            createBubbles();
            initSplashScreen();
            initEventListeners();
        }

        window.addEventListener('beforeunload', cleanupAnimations);
    </script>
</body>
</html>
